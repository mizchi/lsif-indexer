# LSIF Indexer パフォーマンス

## 概要

LSIF Indexerは高速なコードインデックス作成と検索を実現する言語非依存のツールです。
LSP（Language Server Protocol）を活用し、複数言語に対して統一的なインターフェースを提供します。

## パフォーマンス測定結果

### 実環境での性能（自プロジェクト - 約12,000行）

| 項目 | 測定値 | 備考 |
|------|--------|------|
| **フルインデックス** | 0.595秒 | Rust analyzer使用、並列処理 |
| **差分更新** | 0.05秒 | 2-3ファイルの変更時 |
| **メモリ使用量** | < 50MB | 全言語共通 |
| **CPU使用率** | 250% | マルチコア活用 |
| **インデックスサイズ** | 3.3MB | 圧縮済み |

### 言語別パフォーマンス

| 言語 | フルインデックス | LSPサーバー | 特徴 |
|------|-----------------|-------------|------|
| **Rust** | 0.6秒 | rust-analyzer | ネイティブ実装、最高速 |
| **Go** | ~0.5秒 | gopls | 高速、シンプルな統合 |
| **Python** | ~0.8秒 | pylsp/pyright | 動的型付けによる複雑性 |
| **TypeScript** | ~1.0秒 | typescript-language-server | 型推論による処理時間 |

## ベンチマーク

### 実行方法

```bash
# 全ベンチマークを実行
cargo bench

# 特定のベンチマークのみ
cargo bench graph_construction
cargo bench symbol_operations
cargo bench lsif_operations
cargo bench call_hierarchy

# ベースラインとの比較
cargo bench -- --save-baseline main
cargo bench -- --baseline main
```

### ベンチマーク項目

#### 1. グラフ構築性能

| サイズ | シンボル数 | 構築時間 |
|--------|-----------|----------|
| Small | 10 | < 1ms |
| Medium | 100 | ~5ms |
| Large | 1,000 | ~50ms |

#### 2. シンボル操作

| 操作 | 1,000シンボル | 10,000シンボル |
|------|--------------|----------------|
| 検索 | < 0.1ms | < 0.5ms |
| 参照検索 | ~1ms | ~5ms |
| 全シンボル取得 | ~2ms | ~10ms |

#### 3. LSIF生成

| サイズ | シンボル数 | 生成時間 | 出力サイズ |
|--------|-----------|----------|------------|
| Small | 100 | ~10ms | ~50KB |
| Medium | 1,000 | ~100ms | ~500KB |
| Large | 10,000 | ~1s | ~5MB |

## 最適化技術

### 1. 並列処理
- ファイル単位での並列インデックス
- Rayonによる効率的なタスク分散
- CPU使用率250%（マルチコア活用）

### 2. 差分更新
- Git差分を利用した変更ファイル検出
- 影響範囲の最小化
- 0.05秒での高速更新

### 3. メモリ最適化
- インクリメンタルなグラフ構築
- 効率的なシンボルストレージ
- 50MB以下のメモリフットプリント

### 4. ストレージ最適化
- sled DBによる高速永続化
- bincode/MessagePackによる効率的なシリアライズ
- 圧縮による容量削減（3.3MB）

## パフォーマンスチューニング

### 推奨設定

```bash
# CPUコア数に応じた並列度設定
export RAYON_NUM_THREADS=8

# 大規模プロジェクトでのメモリ制限
export RUST_MIN_STACK=8388608

# デバッグログ無効化（本番環境）
export RUST_LOG=warn
```

### ボトルネック対策

1. **LSP起動のオーバーヘッド**
   - LSPサーバーのウォームアップ
   - 接続の再利用

2. **大規模プロジェクト**
   - インクリメンタルインデックス活用
   - 除外パターンの適切な設定

3. **I/O最適化**
   - SSDの使用推奨
   - tmpfsでの一時ファイル処理

## 継続的なパフォーマンス監視

### CI/CDでの自動測定

```yaml
# .github/workflows/benchmark.yml
- name: Run benchmarks
  run: |
    cargo bench -- --save-baseline pr-${{ github.event.pull_request.number }}
    cargo bench -- --baseline main
```

### メトリクス目標

| メトリクス | 目標値 | 現在値 |
|-----------|--------|--------|
| フルインデックス | < 1秒 | ✅ 0.595秒 |
| 差分更新 | < 0.1秒 | ✅ 0.05秒 |
| メモリ使用量 | < 100MB | ✅ 50MB |
| 起動時間 | < 0.5秒 | ✅ 0.3秒 |

## 今後の改善計画

1. **更なる高速化**
   - SIMD命令の活用
   - ゼロコピー最適化
   - カスタムアロケータ

2. **スケーラビリティ**
   - 100万行規模のコードベース対応
   - 分散インデックス構築

3. **インテリジェント最適化**
   - 使用頻度に基づくキャッシュ
   - プリディクティブインデックス